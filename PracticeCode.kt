/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import kotlinx.coroutines.*

//_______________________________________________________

class App {
    val greeting: String = "Hello World!"
}

//_______________________________________________________

suspend fun greet() {
    println("Hello world from a suspending function")
}

suspend fun showUserInfo() {
    println("Loading user...")
    greet()
    println("User: John Smith")
}

suspend fun playWithSuspendables() {
    showUserInfo()
}

//_______________________________________________________

//                          // Coroutine Builder
fun playWithCoroutines1() = runBlocking { // this: CoroutineScope

    // Coroutine Builder
    launch { // launch a new coroutine and continue
        delay(1000L) // non-blocking delay for 1 second (default time unit is ms)
        println("World!") // print after delay
    }
    
    println("Hello") // main coroutine continues while a previous one is delayed
}

//_______________________________________________________
// What Is Concurrency?
//      Programming Model

// What Is Parallelism?
//      Execution Model


//_______________________________________________________

/*
fun playWithCoroutines2() = runBlocking { // this: CoroutineScope :: MC: Parent Coroutine
//fun main() { // this: CoroutineScope
//    GlobalScope.launch { // C1 : Child Coroutine
    launch { // C1: Child
        doWorld()
    } 
    println("Hello")
} 

// this is your first suspending function
suspend fun doWorld() {
    // delay(1000L)
    println("World!")
}
*/

//_______________________________________________________

// import kotlinx.coroutines.*


// Concurrently executes both sections
suspend fun doWorld() = coroutineScope { // this: CoroutineScope

    launch { // C1 : Child
        delay(2000L)
        println("World 2")
    }

    launch { // C2: Child
        delay(1000L)
        println("World 1")
    }
    println("Hello")
}

// Sequentially executes doWorld followed by "Done"
fun playWithCoroutines3() = runBlocking { // Run Blocking Coroutine : Parent

    launch { // Run Blocking Coroutine : Parent
        doWorld()
        println("Done")
    }
}

// Function : playWithCoroutines3
// Hello
// World 1
// World 2
// Done


//_______________________________________________________

// [delay] is a special suspending function that does not block a thread,
// but suspends coroutine and it can be only used from a coroutine.

// main thread invoking runBlocking blocks until the coroutine 
//      inside runBlocking completes.

// Here runBlocking<Unit> { ... } works as an adaptor that is 
//      used to start the top-level main coroutine.

// We explicitly specify its Unit return type, because a well-formed main 
// function in Kotlin has to return Unit .

// When we use GlobalScope.launch , we create a top-level coroutine.
//      Even though it is light-weight, it still  consumes some 
//      memory resources while it runs.

// If we forget to keep a reference to the newly launched coroutine 
//      it still runs.

// What if the code in the coroutine hangs (for example, we erroneously 
//      delay for too long),

//--------------------------------------------------------
// What if we launched too many coroutines and ran out of memory?

// Having to manually keep references to all the launched coroutines and
// [join][Job.join] them is error-prone.
//
// We can use structured concurrency in our code.  
//      Instead of launching coroutines in the [GlobalScope], 
//      just like we usually do with threads (threads are always global)

// we have main function that is turned into a coroutine using 
//  [runBlocking] coroutine builder.

// Every coroutine builder, adds an instance of [CoroutineScope] 
// to the scope of its code block. including runBlocking, launch etc.

//We can launch coroutines in this scope without having to join them 
//  explicitly, because an outer coroutine ( runBlocking in our example) 
//  does not complete until all the coroutines launched in its scope complete.

// In addition to the coroutine scope provided by different builders,
// Tt is possible to declare your own scope using [coroutineScope] builder.
//
//>>> It creates a coroutine scope and does not complete until
//>>> all launched children complete.
//
// The main difference between [runBlocking]
// and [coroutineScope] is that the latter does not block the current thread
// while waiting for all children to complete.


//_______________________________________________________

// Structured Concurrency

fun playWithCoroutines4() = runBlocking { // C0

    println("Starting runBlocking")

    launch { // C1
        // delay( 200L )
        println("Task From Run Blcoking")
    }

    println("Midway runBlocking")

    coroutineScope {
        launch { // C2
            // delay( 300L )
            println("First Coroutine")
        }

        launch { // C3
            // delay( 500L )
            println("Second Coroutine")
        }

        // delay( 100L )
        println("Exiting Coroutine Scope")
    }

    println("Exiting RunBlocking")
}

// Function : playWithCoroutines4
// Starting runBlocking
// Midway runBlocking
// Exiting Coroutine Scope
// Task From Run Blcoking
// First Coroutine
// Second Coroutine
// Exiting RunBlocking

//_______________________________________________________

fun playWithLakhsCoroutines1() = runBlocking {
    var timestampMillis = System.currentTimeMillis()
    println("Starting Time: $timestampMillis")

    repeat( 100_000 ) {
        launch {
            delay( 100L )
            print(".")
        }
    }

    timestampMillis = System.currentTimeMillis()
    println("Ending Time: $timestampMillis")
 
    println("Main Coroutine Exits")
}

//_______________________________________________________

fun playWithLakhsCoroutines2() = runBlocking {
    val job = launch {
        repeat(1000) { i ->
            println("Job: I'm Sleeping: $i...")
            delay( 500L)
        }
    }

    delay(1300L)
    println("I Am Tired Of Waiting...")
    job.cancel()
    job.join()
    println("Main Exiting...")
}

//_______________________________________________________


fun playWithLakhsCoroutines3() = runBlocking {
    GlobalScope.launch {
        repeat( 100_000 ) {
            delay( 500L )
            print(".")
        }
    }

    delay( 1300L )
    println("Main Coroutine Exits")
}

// Active coroutines that were launched in [GlobalScope] 
//      Do not keep the process alive.
//      They are like daemon threads.

//_______________________________________________________

fun playWithTwoCoroutines() = runBlocking { // RB Coroutine :: Parent
    // launch Coroutine Builder
    //      It Will Return Job Object
    //      Job Object Have Reference To Coroutine
    val job = launch { // Child Coroutine :: Child
        repeat(1000) { i ->
            println("Job: I'm Sleeping: $i...")
            delay( 500L)
        }
    }

    delay(1300L)
    println("I Am Tired Of Waiting...")
    // Job Supports cancel and join APIs
    job.cancel() // Cancel In Cooperative In Nature

    // It Will Join To Parent
    //      Parent Will Wait job To Complete
    job.join() 

    println("Main Exiting...")
}


// Function : playWithThousandCoroutines
// Job: I'm Sleeping: 0...
// Job: I'm Sleeping: 1...
// Job: I'm Sleeping: 2...
// I Am Tired Of Waiting...
// Main Exiting..

///**
//      job.cancel()
// * Returns `true` if this job was cancelled for any reason,
//          either by explicit invocation of [cancel] or
// * because it had failed or  parent was cancelled.

// >>>> Its child

// * In the general case, it does not imply that the
//      * job has already [completed][isCompleted],
// because it may still be finishing whatever it was doing and
// *    waiting for its [children] to complete.
// *
// * See [Job] documentation for more details on cancellation and failures.
// */

// public val isCancelled: Boolean

//_______________________________________________________


fun playWithCoroutineCooperation1() = runBlocking {
    val startTime = System.currentTimeMillis()
    
    val job = launch( Dispatchers.Default ) {
        var nextPrintTime = startTime
        var i = 0

        // Cooperative Model Design 
        //      Coding Cooperative Model
        while ( i < 5 ) { // GOVERN BY POLICY
            // IMPORTANT WORK
            if ( System.currentTimeMillis() >= nextPrintTime ) {
                i++
                println("Job: Going To Sleep... ${i}")
                nextPrintTime += 500L
            }
        }
    }
    
    delay( 1300L )
    println("Getting Ready... Exiting Main...")
    job.cancelAndJoin()
    println("Exiting Main..." )
}

//_______________________________________________________

fun playWithCoroutineCooperation2() = runBlocking {
    val startTime = System.currentTimeMillis()

    val job = launch( Dispatchers.Default ) {
        var nextPrintTime = startTime
        var i = 0
        while ( isActive ) { // In Coroutine Active State 
        // Important Work Done!
            if ( System.currentTimeMillis() >= nextPrintTime ) {
                i++
                println("Job: Going To Sleep... ${i}")
                nextPrintTime += 500L
            }
        }
    }
    
    delay( 1300L )
    println("Getting Ready... Exiting Main...")
    job.cancelAndJoin()
    println("Exiting Main..." )
}

// Cancellation is Cooperative
//      Coroutine Cancellation is Cooperative.
//
// A coroutine code has to cooperate to be cancellable.
// All the suspending functions in kotlinx.coroutines are cancellable.
//
// They check for cancellation of coroutine and throw [CancellationException]
//      when cancelled. However, if a coroutine is working in
//      a computation and does not check for cancellation, 
//      then it cannot be cancelled,
//


//_______________________________________________________

fun playWithCoroutineWithResourceManagement() = runBlocking {
    val job = launch {
        try {
            // Opening Resources
            repeat(1000) { i ->
                println("Job Going To Sleep... $i")
                delay(500L)
            }
        } finally {
            // Release Resources
            println("Job: Running Finally Block")
        }
    }
    delay( 1300L )
    println("Main: ")
    job.cancelAndJoin()
    println("Main Exiting")
}

//  Closing resources with finally
//
//  Cancellable suspending functions throw [CancellationException] 
//  on cancellation which can be handled in the usual way. 

//  For example, try {...} finally {...} expression and 
//  Kotlin use function execute their finalization actions normally
//  when a coroutine is cancelled:

// Both [join][Job.join] and [cancelAndJoin] wait for all finalization 
//      actions to complete,

//_______________________________________________________

fun playWithCoroutinesWithContext() = runBlocking {
    val job = launch {
        try {
            repeat( 1000 ) { i ->
                println("Job Going To Sleep... $i")
                delay(500L)
            }
        } finally {
            // Following Block withContext Block Run Atomically
            //      Do Inside withContext ( NonCancellable )
            withContext( NonCancellable ) {
                println("Job Is Running Finally...")
                delay(1000L)
                println("Exiting Non Cancellable Code")
            }
        }
    }

    delay( 1300L )
    println("Main: ")
    job.cancelAndJoin()
    println("Main Exiting")
}

// Run Non-Cancellable Block
//
// Any attempt to use a suspending function in the finally block 
//  of the previous example causes [CancellationException], 
//  because the coroutine running this code is cancelled.

// Usually, this is not a problem, since all well-behaving
// closing operations 
//      closing a file, 
//      cancelling a job, or 
//      closing any kind of a communication channel
//  are usually non-blocking and do not involve any suspending functions.
//
// However, in the rare case when you need to suspend in a 
//       cancelled coroutine
//
//  You can wrap the corresponding code in withContext(NonCancellable) {...} 
//  using [withContext] function and [NonCancellable] context
//

//_______________________________________________________

fun playWithCoroutineTimeout() = runBlocking {
    withTimeout( 1300L ) {
        repeat( 1000 ) { i ->
            println("I Am Sleeping $i")
            delay( 500L )
        }
    }
}

// The TimeoutCancellationException that is thrown by [withTimeout]
// is a subclass of [CancellationException].

// We have not seen its stack trace printed on the console before.
// That is because inside a cancelled coroutine CancellationException
// is considered to be a normal reason for coroutine completion.
// However, in this example we have used withTimeout right inside the main function.

// Since cancellation is just an exception, all resources are closed in the usual way.
// You can wrap the code with timeout in a
// try {...} catch (e: TimeoutCancellationException){...} block
// if  you need to do some additional action specifically on any kind of timeout or
// use the [withTimeoutOrNull] function  that is similar to [withTimeout]
// but returns null on timeout instead of throwing an exception:

//_______________________________________________________

fun playCoroutineWithAsyncAwait() = runBlocking {
    var time = System.currentTimeMillis()
    println("Started At Time: $time")

    // async Is Coroutine Builder
    val one     = async { doSomethingUsefulOne() }
    val two     = async { doSomethingUsefulTwo() }
    val three   = async { doSomethingUsefulThree() }

    println("Three Coroutines Launched...")
    val result1 = one.await()
    val result2 = two.await()
    val result3 = three.await()
    val result = result1 + result2 + result3 // max ( T1, T2, T3 )
    println("The Final Output: $result")

    time = System.currentTimeMillis()
    println("Completed At Time: $time")
}

fun playCoroutineWithAsyncAwaitAgain() = runBlocking {
    var time = System.currentTimeMillis()
    println("Started At Time: $time")

    val one     = doSomethingUsefulOne() 
    val two     = doSomethingUsefulTwo() 
    val three   = doSomethingUsefulThree() 

    println("Three Coroutines Launched...")
    val result1 = one
    val result2 = two
    val result3 = three
    val result = result1 + result2 + result3 // max ( T1, T2, T3 )
    println("The Final Output: $result")

    time = System.currentTimeMillis()
    println("Completed At Time: $time")
}

suspend fun doSomethingUsefulOne() : Int { // T1
    delay( 3000L )
    return 33
}

suspend fun doSomethingUsefulTwo() : Int { // T2
    delay( 2000L )
    return 22
}

suspend fun doSomethingUsefulThree() : Int { // T3
    delay( 5000L )
    return 55
}

//_______________________________________________________
//_______________________________________________________
//_______________________________________________________
//_______________________________________________________
//_______________________________________________________
//_______________________________________________________


// fun main() = runBlocking {
fun main() {

    // println("\nFunction : App.greeting")
    // App().greeting
    
    // println("\nFunction : playWithSuspendables")
    // playWithSuspendables()

    // println("\nFunction : playWithCoroutines1")
    // playWithCoroutines1()

    // println("\nFunction : playWithCoroutines2")
    // playWithCoroutines2()

    // println("\nFunction : playWithCoroutines3")
    // playWithCoroutines3()

    // println("\nFunction : playWithCoroutines4")
    // playWithCoroutines4()

    // println("\nFunction : playWithLakhsCoroutines")
    // playWithLakhsCoroutines()

    // println("\nFunction : playWithLakhsCoroutines2")
    // playWithLakhsCoroutines2()

    // println("\nFunction : playWithLakhsCoroutines3")
    // playWithLakhsCoroutines3()

    // println("\nFunction : playWithTwoCoroutines")
    // playWithTwoCoroutines()

    // println("\nFunction : playWithCoroutineCooperation1")
    // playWithCoroutineCooperation1()

    // println("\nFunction : playWithCoroutineCooperation2")
    // playWithCoroutineCooperation2()

    // println("\nFunction : playWithCoroutineWithResourceManagement")
    // playWithCoroutineWithResourceManagement()

    // println("\nFunction : playWithCoroutinesWithContext")    
    // playWithCoroutinesWithContext()

    // println("\nFunction : playWithCoroutineTimeout")
    // playWithCoroutineTimeout()

    println("\nFunction : playCoroutineWithAsyncAwait")    
    playCoroutineWithAsyncAwait()

    println("\nFunction : playCoroutineWithAsyncAwaitAgain")
    playCoroutineWithAsyncAwaitAgain()

    // println("\nFunction :")    
    // println("\nFunction :")
    // println("\nFunction :")    
}

